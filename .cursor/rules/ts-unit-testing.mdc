---
description: ALWAYS use when writing or modifying unit tests to ensure comprehensive test coverage. This rule enforces test structure, proper assertions, and thorough edge case testing in TypeScript.
globs: "**/*.{test,spec}.{ts,tsx}"
---
<?xml version="1.0" encoding="UTF-8"?>
<cursor_rules>
    <rule>
        <n>unit_testing_standards</n>
        <description>Standards for writing and maintaining high-quality unit tests</description>
        
        <filters>
            <filter>
                <type>file_extension</type>
                <pattern>\.(test|spec)\.(ts|js)$</pattern>
            </filter>
            <filter>
                <type>content</type>
                <pattern>(?s)(describe|test|it)\s*\(</pattern>
            </filter>
        </filters>

        <guidelines>
            <section name="test_structure">
                <title>Test Structure and Naming</title>
                <guidelines>
                    <item>Use descriptive 'describe' blocks to group related tests</item>
                    <item>Write clear 'it' statements that explain the expected behavior</item>
                    <item>Follow the pattern: "it should [expected behavior] when [condition]"</item>
                </guidelines>
                <example>
                    <code>
                    describe('UserService', () => {
                      describe('createUser', () => {
                        it('should create user when valid data is provided', () => {
                          // test code
                        });
                      });
                    });
                    </code>
                </example>
            </section>

            <section name="coverage">
                <title>Test Coverage Requirements</title>
                <requirements>
                    <item>Maintain minimum 80% test coverage for all public functions</item>
                    <item>Test both success and failure paths</item>
                    <item>Include edge cases and boundary conditions</item>
                    <item>Document any intentionally uncovered code with clear reasoning</item>
                </requirements>
            </section>

            <section name="test_data">
                <title>Test Data and Mocking</title>
                <guidelines>
                    <item>Mock external dependencies (APIs, databases, etc.)</item>
                    <item>Use meaningful test data that represents real scenarios</item>
                    <item>Create helper functions for commonly used test data</item>
                </guidelines>
                <example>
                    <code>
                    jest.mock('./database');
                    const mockDb = {
                      query: jest.fn().mockResolvedValue([/* test data */])
                    };
                    </code>
                </example>
            </section>

            <section name="edge_testing">
                <title>Edge and Boundary Testing</title>
                <guidelines>
                    <item>Test minimum and maximum values</item>
                    <item>Test empty/null/undefined inputs</item>
                    <item>Test invalid inputs and error conditions</item>
                    <item>Test boundary transitions</item>
                </guidelines>
                <example>
                    <code>
                    describe('validateAge', () => {
                      it('should reject age below 0', () => {});
                      it('should accept age at minimum (0)', () => {});
                      it('should accept age at maximum (120)', () => {});
                      it('should reject age above maximum', () => {});
                    });
                    </code>
                </example>
            </section>

            <section name="organization">
                <title>Test Organization</title>
                <guidelines>
                    <item>Keep test files alongside source files</item>
                    <item>Name test files with .test.ts or .spec.ts extension</item>
                    <item>Group related tests using nested describe blocks</item>
                    <item>Use beforeEach/afterEach for test setup/cleanup</item>
                </guidelines>
            </section>

            <section name="assertions">
                <title>Assertions and Expectations</title>
                <guidelines>
                    <item>Make one logical assertion per test</item>
                    <item>Use specific matchers (prefer toEqual over toBeTruthy)</item>
                    <item>Write meaningful error messages</item>
                </guidelines>
                <example>
                    <code>
                    expect(result).toEqual(expectedValue);
                    expect(errorFn).toThrow('Invalid input');
                    </code>
                </example>
            </section>
        </guidelines>

        <examples>
            <example type="bad">
                <title>Unclear test description</title>
                <code>
                it('test1', () => {
                  expect(sum(1, 1)).toBe(2);
                });
                </code>
            </example>
            <example type="good">
                <title>Clear test description and structure</title>
                <code>
                describe('Calculator', () => {
                  describe('sum', () => {
                    it('should return correct sum when given two positive numbers', () => {
                      expect(sum(1, 1)).toBe(2);
                    });
                  });
                });
                </code>
            </example>
        </examples>

        <metadata>
            <priority>high</priority>
            <version>1.0</version>
        </metadata>
    </rule>
</cursor_rules> 